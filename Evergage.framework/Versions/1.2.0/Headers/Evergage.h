//
//  Evergage.h
//  Evergage
//
//  Copyright (c) 2015 Evergage. All rights reserved.
//

// VERSION: 1.2.0

#if (TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR) && __IPHONE_OS_VERSION_MIN_REQUIRED < 70000
#error Evergage Framework requires Deployment Target iOS 7.0+
#endif

// Required system frameworks:
#import <UIKit/UIKit.h>
#import <Foundation/Foundation.h>
#import <SystemConfiguration/SystemConfiguration.h> // Reachability, network connectivity
// Also note zlib.h will be used for gzip compression to reduce bandwidth

// Other public Evergage headers:
#import <Evergage/EVGContext.h>
#import <Evergage/UIViewController+Evergage.h>
#import <Evergage/EVGScreen.h>
#import <Evergage/EVGItems.h>
#import <Evergage/EVGCampaign.h>
#import <Evergage/EVGConstants.h>

/**
 This class is primarily used to start and configure Evergage, through the singleton `<+sharedInstance>`.
 
 Tracking user interactions should typically be done from a `UIViewController`,
 see `<EVGContext>` for the APIs and `<[UIViewController(Evergage) evergageScreen]>` for using them from a view controller.
 
 ## Startup
 Initialize and configure Evergage in `UIApplicationDelegate -willFinishLaunchingWithOptions:`. First enable logging and
 design mode during development in DEBUG builds. Then provide the app's Evergage configuration using
 `<-startWithEvergageAccountKey:dataset:>`. Finally, when the user is logged-in it is recommended to provide the user ID
 to correlate user activity across devices.
 
 Other methods in this class can be used to add information about the user/account.
 In the examples below, setting `<userId>` provides Evergage with the user's logged-in ID. This could also
 have been called later if the user's ID was not known at startup and it would be sent with the next event.

 ### Obj-C:
    // In AppDelegate.m
    #import <Evergage/Evergage.h>
 
    - (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 
        Evergage *evergage = [Evergage sharedInstance];

    #ifdef DEBUG
        // Developer settings
        evergage.logLevel = EVGLogLevelWarn;
        [evergage allowDesignConnections];
    #endif
        
        // Change the account name and dataset to match yours:
        [evergage startWithEvergageAccountKey:@"mycompany" dataset:@"engage"];
 
        // Recommended as soon as the user ID is known:
        evergage.userId = @"johndoe";

        // ... existing code from your app starts here

        return YES;
    }
 
 ### Swift:
    // In Obj-C bridging header:
    #import <Evergage/Evergage.h>
 
    // In AppDelegate.swift:
    func application(application: UIApplication, willFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
 
        let evergage = Evergage.sharedInstance()
 
        // For the DEBUG conditional to work in Swift, you must edit your project/target's Build Settings:
        // Expand "Other Swift Flags" and add "-DDEBUG" under Debug. Do not add to Release!
    #if DEBUG
        // Developer settings
        evergage.logLevel = EVGLogLevel.Warn
        evergage.allowDesignConnections()
    #endif
 
        // Change the account name and dataset to match yours:
        evergage.startWithEvergageAccountKey(@"mycompany", dataset: @"engage")
 
        // Recommended as soon as the user ID is known:
        evergage.userId = "johndoe"
 
        // ... existing code from your app starts here
 
        return true
    }

 ## Lifecycle
 Once `<-startWithEvergageAccountKey:dataset:>` has been called at app launch, the Evergage client will
 track user activity, send any applicable events to the Evergage server, and support any data campaigns in response.
 Evergage will monitor network availability and store events if necessary, sending them when the network becomes available again.
 
 ## Tracking Screens
 The Evergage client supports automatically tracking UIViewControllers and dynamically mapping and re-mapping them
 to view actions using the Evergage web app.
 See `<UIViewController(Evergage)>`, `<EVGScreen>`, and the <Integration> Guide.

 ## Tracking Item Views and Activity
 Evergage can track how the user views and interacts with articles, blogs and products which are collectively called items.
 Evergage understands the actions that are possible on these items (View, Comment, Purchase, etc.) and also how they
 relate to each other (categories, brands, keywords, etc.).  See `<EVGContext>`.
 
 ## Campaigns
 Campaigns may be served in response to actions generated by the user interacting with the app,
 delivered to a screen's app-defined target, and are handled by app-defined code.
 See `<EVGContext>` and `<EVGCampaign>`.
 */
@interface Evergage : NSObject

- (nullable instancetype)init __attribute__((unavailable("Use sharedInstance to obtain Evergage singleton")));


/// ---------------------------------
#pragma mark - Required Integration
/// @name Required Integration
/// ---------------------------------

/**
 @return The Evergage singleton instance.
 */
+ (nonnull instancetype)sharedInstance;

/**
 Starts Evergage with the specified account and dataset.
 Recommended to call from `willFinishLaunchingWithOptions:`, see `<Evergage>`
 class doc for full startup code snippet including developer/DEBUG settings etc.
 Once started, subsequent calls will have no effect, unless `<reset>` has been
 called due to an environment change.
 
 @param accountKey Account within Evergage to use.
 @param dataset Dataset within the Evergage account to use.
 @see reset
 */
- (void)startWithEvergageAccountKey:(nonnull NSString *)accountKey dataset:(nonnull NSString *)dataset;

/**
 Notify Evergage when the app is opening an URL. Used so test campaigns can easily be controlled by
 opening an URL instead of programmatically calling methods like `<includeTestCampaigns>` etc.
 
 @param url The URL that the app is opening via `application:openURL:options:` (iOS9+),
            `application:openURL:sourceApplicatoin:annotation:`, or `application:handleOpenURL:`.
 @return YES if the URL was Evergage specific
 @since 1.2.0
 */
- (BOOL)handleOpenURL:(nonnull NSURL *)url;


/// ---------------------------------
#pragma mark - User Info
/// @name User Info
/// ---------------------------------

/**
 The user's persistent ID. Setting this property makes it easier to find users in reports and allows Evergage to
 correlate that user's activity across devices. Evergage will also identify the user by `identifierForVendor`,
 regardless of the value of this property. Activity using one or more of these anonymous identifiers will be combined
 automatically once the persistent ID is provided with this method.
 
 Recommended to set this property whenever the app's user is logged-in,
 including at app launch when your app determines the user is still logged-in.
 If the user logs out, you should set this to nil, which will also set accountId to nil.
 */
@property (nullable, atomic, copy) NSString *userId;

/**
 The optional account this user belongs to. Set this property to track which of your accounts users belong to inside the Evergage
 dataset and account.  If account is no longer applicable, it can be set to nil.
 */
@property (nullable, atomic, copy) NSString *accountId;

/**
 Sets an attribute (a name/value pair) on the user. The new value will be sent to the Evergage server with the next
 event.
 
 @param attributeValue The new value of the user attribute, which replaces any existing value.  Set nil to clear.
 @param attributeName The name for the user attribute.
 */
- (void)setUserAttribute:(nullable NSString *)attributeValue forName:(nonnull NSString *)attributeName;

/**
 Sets an attribute (a name/value pair) on the account. The new value will be sent to the Evergage server with the next
 event.
 
 @param attributeValue The new value of the account attribute, which replaces any existing value.  Set nil to clear.
 @param attributeName The name for the account attribute.
 */
- (void)setAccountAttribute:(nullable NSString *)attributeValue forName:(nonnull NSString *)attributeName;


/// ---------------------------------
#pragma mark - Tracking Non-Screen Actions
/// @name Tracking Non-Screen Actions
/// ---------------------------------

/**
 Context to use for non-screen actions.
 
 When applicable to a screen, the same methods on `<EVGScreen>` (extending `<EVGContext>`)
 should always be preferred over the global context, because the screen methods enable that
 screen to potentially receive campaigns in response.
 
 Methods on the global context are intended for tracking non-screen events, and as a result cannot deliver campaigns to a screen.
 
 Nil if Evergage is disabled.
 
 @since 1.2.0
 */
@property (nullable, readonly) EVGContext *globalContext;

/**
 Deprecated, use same method on `<EVGContext>` instead, from `<[UIViewController(Evergage) evergageScreen]>` or  `<globalContext>`.
 Send a non-screen event to Evergage describing an action that is not automatically tracked.
 
 @param action A short string that identifies the type of action.
 @see globalContext
 @see [EVGContext trackAction:]
 @deprecated As of 1.2.0
 */
- (void)trackAction:(nonnull NSString *)action __attribute__((deprecated("Use same method on EVGContext instead, from a UIViewController's 'evergageScreen' or Evergage's 'globalContext'")));


/// ---------------------------------
#pragma mark - Developer Settings
/// @name Developer Settings
/// ---------------------------------

/**
 Configures the threshold `<EVGLogLevel>` of messages to log. Will only log messages at this level of severity or greater.
 
 Recommended to set only during development in DEBUG builds.
 */
@property EVGLogLevel logLevel;

/**
 Allow user-initiated gesture to connect to the Evergage web app for action mapping screens. Once granted, permission lasts until app termination.
 
 Recommended to use only during development in DEBUG builds.
 */
- (void)allowDesignConnections;

/**
 Resets the SDK so `startWithEvergageAccountKey:dataset:>` can be called again with a different dataset, in order to
 support apps that change environments (production, demo, QA, etc) and want to change Evergage datasets as well.
 
 Reset will clear settings, unsent actions, held campaigns, test campaign settings, allowDesignConnections, userId, accountId, and unsent attributes.
 
 Reset will keep existing campaign handlers, screen visibility, and items being viewed, since it would potentially be cumbersome/confusing to require
 once again setting handlers, potentially mocking viewWillAppear or renavigating to screens, setting items being viewed, etc.

 Ideally the app will avoid environment churn:
 
 - On app launch, if the user must select/confirm the environment before using the app, consider delaying the
   call to `<startWithEvergageAccountKey:dataset:>` to when the environment is chosen and avoid calling reset.
 - Otherwise, if the user can immediately use the app with the current environment, call `<startWithEvergageAccountKey:dataset:>`
   as normal with the corresponding dataset.  And when the environment later changes, and a different Evergage dataset
   is desired, call reset as demonstrated below.
 
 #### Recommended Usage:
    // If the app is changing to a different server environment and a different Evergage dataset is desired..
    
    // Reset Evergage SDK just before changing the environment:
    Evergage *evergage = [Evergage sharedInstance];
    [evergage reset];
 
    // ... app changes server environment
 
    // Start Evergage SDK again with the dataset to use with the new environment:
    // See `<Evergage>` class doc for full startup code snippet including developer/DEBUG settings etc.
    [evergage startWithEvergageAccountKey:@"<your account>" dataset:@"<corresponding dataset>"];
 */
- (void)reset;

/**
 In addition to default behavior of showing mobile campaigns in Published state, also show mobile campaigns
 that are in Test state.  All campaign rules will still be active.
 
 Effect lasts until app termination, or until modified by calling `<disableTestCampaigns>` or `<includeSpecificTestCampaignExperience:>`.
 
 Note `<handleOpenURL:>` can be used to accomplish this functionality without a programmatic method call.
 
 Recommended to use only during development in DEBUG builds, whereas handleOpenURL: can safely be used in all builds.
 */
- (void)includeTestCampaigns;

/**
 In addition to default behavior of showing mobile campaigns in Published state, also show the particular experience
 of a mobile campaign that is in Test or Published state, regardless of whether rules would normally cause it to be shown.
 Does not aggregate over multiple calls nor combine with `<includeTestCampaigns>`.
 
 Effect lasts until app termination, or until modified by calling `<includeTestCampaigns>` or `<disableTestCampaigns>`.
 
 Note `<handleOpenURL:>` can be used to accomplish this functionality without a programmatic method call.
 
 Recommended to use only during development in DEBUG builds, whereas handleOpenURL: can safely be used in all builds.
 
 @param experienceId Identifier of the particular experience that should be shown.
 @return NO if does not appear to be a valid experience id format
 */
- (BOOL)includeSpecificTestCampaignExperience:(nonnull NSString *)experienceId;

/**
 Return to the default behavior of showing mobile campaigns in Published state only.
 
 Effect lasts until app termination, or until modified by calling `<includeTestCampaigns>` or `<includeSpecificTestCampaignExperience:>`.
 
 Note `<handleOpenURL:>` can be used to accomplish this functionality without a programmatic method call.
 
 Recommended to use only during development in DEBUG builds, whereas handleOpenURL: can safely be used in all builds.
 */
- (void)disableTestCampaigns;

@end
